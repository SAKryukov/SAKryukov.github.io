<DOCTYPE html>
<html>
    <head>
        <title>Tetris on Canvas &mdash; Settings</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="generator" content="SAEditU Unicode editor, XHTML plug-in, (c) 2004, 2007 by S A Kryukov, http://www.SAKryukov.org" />
        <title>Tetris on Canvas</title>
        <style type="text/css">
            * { font-family: "Verdana", sans-serif; }
            src { font-family: monospace; font-size: 120%; color: darkblue; font-weight: bold; }
            details ul { list-style-type: none; margin-top: 0.1em; }
            details { margin-top: 0.2em; margin-bottom: 0.2em; }
            p { margin-top: 1em; margin-bottom: 0; }
            main { display: table-row; width: 100%; }
            section { display: table-cell; }
            main > section:first-child { background-color: transparent; width: 50%; padding-left: 2em; padding-right: 2em; }
            main > section:last-child { background-color: transparent; border-left: solid thin black; padding-left: 2em; vertical-align: bottom; }
            button { white-space: nowrap; }
	        main > section:last-child button { margin-top: 2em; }
            table { margin-top: 0.4em; margin-left: 2em; }
            td, tr { margin: 0; padding: 0; }
            td.keyCode { text-align: right; }
            tr > td:first-child { padding-right: 0.2em; }
            input[type=text] { margin-left: 0.2em; }
            input[type=checkbox] { margin: 0; }
            table.default select { width: 8em; }
            details table:last-child { margin-bottom: 1em; }
            ul.keyboard button { padding: 0; padding-left: 0.2em; padding-right: 0.2em; }
            ul.keyboard button, ul.keyboard li input { margin: 0; }
            ul.keyboard input { width: 12em; }
            #keyEditor { display: none; position: absolute; background-color: moccasin; padding: 0.2em; padding-left: 1em; padding-right: 1em;  }
            aside { width: 2em; height: 1em; display: inline-block; margin-right: 0.4em; }
        </style>
    <head>
<body>

<h2>Settings</h2>

<div id="keyEditor"></div>

<h4>Tetris On Canvas v.&ThinSpace;<span id="version"></span></h4>

<main>

<section>

<details open="true">
    <summary accesskey="G"><u>G</u>ame size</summary>
    <table class="default">
        <tr>
            <td>Horizontal:</td><td><select data-property="gameSizeInBlocks.x" data-editor="gameSizeInBlocksEditor.x"></select></td>
        </tr>
        <tr>
            <td>Vertical:</td><td><select data-property="gameSizeInBlocks.y" data-editor="gameSizeInBlocksEditor.y"></td>
        </tr>
    </table>
</details>

<details open="true">
    <summary accesskey="Y">Dela<u>y</u>s</summary>
    <table class="default">
        <tr>
            <td>Start:</td><td><select data-property="delays.start" data-editor="delaysEditor.start"></select></td>
        <tr>
            <td>Decrement:</td><td><select data-property="delays.decrement" data-editor="delaysEditor.decrement"></select></td>
        </tr>
        <tr>
            <td>Minimum:</td><td><select data-property="delays.min" data-editor="delaysEditor.min"></select></li></td>
        </tr>
    </table>
</details>

<details open="true">
    <summary accesskey="C"><u>C</u>olors</summary>
    <table class="colors">
        <tr>
        <td><img id="image.J" src="images/settings.J.png"/></li>
        <td><img id="image.S" src="images/settings.S.png"/></li>
        <td><img id="image.T" src="images/settings.T.png"/></li>
        </tr>
        <tr>
        <td><select data-property="tetrominoColor.J"></select></td>
        <td><select data-property="tetrominoColor.S"></select></td>
        <td><select data-property="tetrominoColor.T"></select></td>
        </tr>
    </table>
    <table class="colors">
        <tr>
        <td><img id="image.L" src="images/settings.L.png"/></td>
        <td><img id="image.Z" src="images/settings.Z.png"/></td>
        <td><img id="image.O" src="images/settings.O.png"/></td>
        <td><img id="image.I" src="images/settings.I.png"/></li>
        </tr>
        <tr>
        <td><select data-property="tetrominoColor.L"></select></td>
        <td><select data-property="tetrominoColor.Z"></select></td>
        <td><select data-property="tetrominoColor.O"></select></td>
        <td><select data-property="tetrominoColor.I"></select></td>
        </tr>
    </table>
</details>

<details>
    <summary accesskey="U">Cl<u>u</u>tter</summary>
    <table class="default">
        <tr>
            <td><label for="clutterEnabledDefault" accesskey="E"><u>E</u>nabled by default:</td><td><input type="checkbox" data-property="clutterOptionSet.clutterEnabledDefault" id="clutterEnabledDefault"></input></label></td>
        </tr>
        <tr>
            <td>Minimum:</td><td><select data-property="clutterOptionSet.min" data-editor="clutterEditor.min"></select></td>
        </tr>
        <tr>
            <td>Maximum:</td><td><select data-property="clutterOptionSet.max" data-editor="clutterEditor.max"></select></td>
        </tr>
        <tr>
            <td>Step:</td><td><select data-property="clutterOptionSet.step" data-editor="clutterEditor.step"></select></td>
        </tr>
        <tr>
            <td><u>D</u>efault value:</td><td><select accesskey="D" data-property="clutterOptionSet.default" data-editor="clutterEditor.default"></select></td>
        </tr>    
    </table>
</details>

<details>
    <summary accesskey="K"><u>K</u>eyboard</summary>
    <table>
        <tr data-property="key.start">
            <td>Start/Pause/Continue:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.cancel">
            <td>Cancel:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.left">
            <td>Left:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.right">
            <td>Right:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.down">
            <td>Down:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.dropDown">
            <td>Drop Down:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.rotate">
            <td>Rotate:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.help">
            <td>Help:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.downloadSource">
            <td>Download source code:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td>
        </tr>
        <tr data-property="key.settings">
            <td>Settings:</td><td class="keyCode"></td><td><input type="text"></input><button>&Congruent;</button></td> 
        </tr>
    </table>
</details>

</section>

<section>
    <button id="apply" accesskey="A" title="Store custom settings and play game"><u>A</u>pply</button><br/>
    <button id="reset" accesskey="R" title="Reset settings to default values"><u>R</u>eset</button><br/>
    <button id="clean" accesskey="L" title="Clean Tetris data from browser local storage">Clean <u>L</u>ocal Storage</button>    
</section>

</main>

<script src="settings.js"></script>
<script>
    
    "use strict";

    const setTargetImage = (node) => {
        const cell = node.parentElement;
        if (cell.constructor != HTMLTableCellElement) return;
        let tetrominoName = node.dataset.property.split('.');
        tetrominoName = tetrominoName[tetrominoName.length - 1];
        const tetrominoId = "image." + tetrominoName;
        const targetImage = document.getElementById(tetrominoId);
        if (!targetImage) return null; 
        node.targetImage = targetImage; 
        return targetImage;
    }; //setTargetImage

    const detectKeyboardEditorElements = (node) => {
        const numericKeyCodeElement = node.firstElementChild.nextSibling;
        const button = node.lastElementChild.lastElementChild;
        const inputName = node.lastElementChild.firstElementChild;
        return { numericKeyCodeElement: numericKeyCodeElement, button: button, inputName: inputName };
    }; //detectKeyboardEditorElements
    
    const populate = (elements, defaultOnly) => {
        const effectiveSettings = getSettings(defaultOnly);
        const effectiveSettingsNamePrefix = settingsEditor.getVariableName({effectiveSettings}) + ".";
        settingsEditor.traverse(document.body, function(node) {
            if (!node.dataset) return;
            if (!node.dataset.property) return;
            let value = eval(effectiveSettingsNamePrefix + node.dataset.property);
            if (node.constructor == HTMLTableRowElement) { // keyboard
                const keyboardEditorElements = detectKeyboardEditorElements(node);            
                keyboardEditorElements.numericKeyCodeElement.textContent = value.keyCode;
                keyboardEditorElements.inputName.value = value.display;
                keyboardEditorElements.inputName.data = {};
                keyboardEditorElements.inputName.data.keyCode = value.keyCode;
                keyboardEditorElements.button.onclick = () => {
                    elements.keyEditor.tabIndex = 0;
                    elements.keyEditor.onkeydown = (event) => {
                        event.preventDefault();
                        event.target.innerHTML = event.keyCode;
                        keyboardEditorElements.inputName.value = event.code;
                        keyboardEditorElements.inputName.data = {};
                        keyboardEditorElements.inputName.data.keyCode = event.keyCode;
                        event.target.style.display = "none";
                        keyboardEditorElements.numericKeyCodeElement.textContent = event.keyCode; 
                        keyboardEditorElements.inputName.focus();
                    }; //elements.keyEditor
                    const bounds = keyboardEditorElements.button.getBoundingClientRect();
                    elements.keyEditor.innerHTML = settingsEditor.keyEditorInstruction;
                    elements.keyEditor.style.display = "block";
                    elements.keyEditor.style.top = (bounds.top + window.pageYOffset).toString();
                    elements.keyEditor.style.left = (bounds.right + window.pageXOffset).toString();
                    elements.keyEditor.focus();
                }; //keyboardEditorElements.button.onclick
            } else if (node.constructor == HTMLSelectElement) {
                while (node.firstChild)
                    node.removeChild(node.firstChild);
                if (setTargetImage(node)) { // case of image
                    node.onchange = function(event) {
                        if (event.target.targetImage.constructor == HTMLImageElement)
                            event.target.targetImage.style.backgroundColor = event.target.value;
                    }; //node.onselect
                    for (let color of settingsEditor.namedCssColors) {
                        const option = document.createElement("option");
                        const colorBox = document.createElement("aside");
                        colorBox.style.backgroundColor = color;
                        const colorName = document.createTextNode(color);
                        option.appendChild(colorBox);
                        option.appendChild(colorName);
                        option.selected = value.toLowerCase() == color.toLowerCase();
                        option.value = color;
                        node.add(option);
                    } //loop
                    node.targetImage.style.backgroundColor = node.value;
                } else { //if image, now considering text
                    const editorOptionSet = eval(effectiveSettingsNamePrefix + node.dataset.editor);
                    if (!editorOptionSet) return;
                    const count = ((editorOptionSet.max - editorOptionSet.min) / editorOptionSet.step) + 1;
                    const rounder = settingsEditor.findRoundingFactor(editorOptionSet);
                    for (let index = 0; index < count; ++index) {
                        let optionValue = editorOptionSet.min + index * editorOptionSet.step;
                        optionValue = Math.floor(optionValue * rounder) / rounder; 
                        const option = document.createElement("option");
                        option.selected = optionValue == value;
                        option.textContent = optionValue + editorOptionSet.unit;
                        node.add(option);
                    } //loop
                } //if text
            } else if (node.constructor == HTMLInputElement && node.type == "checkbox") {
                node.checked = value;
            } else // not editable
                settingsEditor.setText(node.id, value);
        });
    }; //populate

    const extractKeyboardData = (node) => {
        const parentProperty = eval(node.dataset.property)
        const keyboardEditorElements = detectKeyboardEditorElements(node);
        const keyCode = keyboardEditorElements.inputName.data.keyCode;
        const display = keyboardEditorElements.inputName.value;
        parentProperty.keyCode = keyCode;
        parentProperty.display = display;
        return parentProperty;
    }; //extractKeyboardData

    const apply = () => {
        const target = {};
        settingsEditor.traverse(document.body, function(node) {
            if (!node.dataset) return;
            if (!node.dataset.property) return;
            if (node.constructor != HTMLTableRowElement && node.constructor != HTMLSelectElement && node.type != "checkbox") return;
            const propertyChain = node.dataset.property.split(".");
            let currentObject = target;
            let lastSlot = null;
            let value = null;
            if (node.constructor == HTMLTableRowElement) {
                value = extractKeyboardData(node);
            } else {
                value = node.value;
                if (node.type == "checkbox") 
                    value = node.checked;
                else {
                    const numericValue = parseFloat(node.value);
                    if (!Number.isNaN(numericValue)) value = numericValue;
                } //if
            } //if
            if (value == undefined || value == null) return;
            for (let index = 0; index < propertyChain.length; ++index) {
                if (currentObject[propertyChain[index]] != undefined)
                    currentObject = currentObject[propertyChain[index]];
                else {
                    if (index == propertyChain.length - 1)
                        currentObject[propertyChain[index]] = value;
                    else
                        currentObject[propertyChain[index]] = {};
                    currentObject = currentObject[propertyChain[index]]; 
                } //if
            } //loop slots
        });
        const result = JSON.stringify(target);
        localStorage.setItem(settingsEditor.localStorageKey, result);
        window.location = fileNames.main;
    }; //apply

    window.onload = () => {
        const elements = { keyEditor: document.getElementById("keyEditor") };
        document.getElementById("version").textContent = version;
        populate(elements, false);
        const buttonApply = document.getElementById("apply");
        buttonApply.onclick = apply;
        const buttonClean = document.getElementById("clean");
        const buttonReset = document.getElementById("reset");
        buttonReset.onclick = () => {
            populate(elements, true);
        }; //buttonReset.onclick
        buttonClean.onclick = () => {
            localStorage.removeItem(settingsEditor.localStorageKey);
            location.reload(true);
        }; //buttonClean.onclick
    }; //window.onload
</script>

</body></html>