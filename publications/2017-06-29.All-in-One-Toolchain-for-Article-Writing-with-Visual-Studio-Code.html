<!DOCTYPE html>
<html>
<head>
    <title>All in One Toolchain for Article Writing with Visual Studio Code</title>
    <meta charset="utf-8"/>
    <style type="text/css">
        @import url(https://SAKryukov.github.io/publications/code/documentation.css);
        table, td, th { border: solid thin black; border-collapse: collapse; font-size: 120%; font-weight: normal; }
        td, th  { vertical-align: middle; padding-left: 0.4em; padding-right: 0.4em; }
        th { background-color: lightblue; }
        table { width: 100% }

    </style>
</head>
<body>

<p class="title">All in One Toolchain for Article Writing with Visual Studio Code</p><p class="author"><a href="https://www.SAKryukov.org"><em>Sergey A Kryukov</em></a></p><p><em>New Visual Studio Code extension “Extensible Markdown Converter” augments built-in Markdown extension to form all in one toolchain offering convenient editor, rendered document viewer, spell checker and converter to HTML, per CodeProject article submission requirements</em></p><div  data-line="6" class="code-line" dir="auto" ></div>
<!-- <h2>Contents</h2> is not Markdown element, just to avoid adding it to TOC -->
<div  data-line="7" class="code-line" dir="auto" ></div>
<!-- change style in next line <ul> to <ul style="list-style-type: none"> -->
<div  data-line="8" class="code-line" dir="auto" ></div>
<!--
For CodeProject, makes sure there are no HTML comments in the area to past!
--> 
<hr data-line="12" class="code-line" dir="auto" />
<div  data-line="14" class="code-line" dir="auto" ></div>
<!-- copy to CodeProject from here ------------------------------------------->
<p><img src="Resources-articles/2017-06-29.All-in-One-Toolchain-for-Article-Writing-with-Visual-Studio-Code.title.webp" alt="Extensible Markdown" data-src="Resources-articles/2017-06-29.All-in-One-Toolchain-for-Article-Writing-with-Visual-Studio-Code.title.webp" /></p><div  data-line="19" class="code-line" dir="auto" ></div>
<ul class="download">
    <li><a href="https://github.com/SAKryukov/vscode-markdown-to-html">Download or clone extension source code from GitHub</a></li>
    <li><a href="Visual-Studio-Code-Markdown-samples.zip">Download Visual Studio Code workspace and document samples &mdash; 8 KB</a></li>
</ul>
<div  data-line="24" class="code-line" dir="auto" ></div>
<blockquote id="epigraph" class="FQ"><div class="FQA">Epigraph:</div>
<p><i>Beware of advice — even this.</i></p>
<dd><a href="https://en.wikipedia.org/wiki/Carl_Sandburg">Carl Sandburg</a></dd>
</blockquote>
<h2>Contents</h2>
<p class="toc">
<a style="margin-left: 0em;" href="#heading-important-note-on-the-article-update">Important Note on the Article Update</a><br/>
<a style="margin-left: 0em;" href="#heading-introduction">Introduction</a><br/>
<a style="margin-left: 0em;" href="#heading-visual-studio-code">Visual Studio Code</a><br/>
<a style="margin-left: 0em;" href="#heading-available-extensions">Available Extensions</a><br/>
<a style="margin-left: 6em;" href="#heading-vs-code-markdown2c-microsoft">VS Code Markdown, Microsoft</a><br/>
<a style="margin-left: 6em;" href="#heading-markdown-all-in-one">Markdown All in One</a><br/>
<a style="margin-left: 6em;" href="#heading-code-spellchecker-extension">Code Spellchecker Extension</a><br/>
<a style="margin-left: 0em;" href="#heading-so2c-where-is-the-problem3f">So, Where is the Problem?</a><br/>
<a style="margin-left: 0em;" href="#heading-the-solution3a-extensible-markdown">The Solution: Extensible Markdown</a><br/>
<a style="margin-left: 3em;" href="#heading-markdown-it-initialization">Markdown-it Initialization</a><br/>
<a style="margin-left: 3em;" href="#heading-performance-optimization-with-lazy-evaluation">Performance Optimization with Lazy Evaluation</a><br/>
<a style="margin-left: 3em;" href="#heading-auto-numbering">Auto-Numbering</a><br/>
<a style="margin-left: 3em;" href="#heading-setting-up-additional-plug-ins">Setting up Additional Plug-ins</a><br/>
<a style="margin-left: 0em;" href="#heading-customized-workspace-settings">Customized Workspace Settings</a><br/>
<a style="margin-left: 0em;" href="#heading-putting-all-together3a-cookbook-recipe">Putting All Together: Cookbook Recipe</a><br/>
<a style="margin-left: 0em;" href="#heading-versions">Versions</a><br/>
<a style="margin-left: 0em;" href="#heading-conclusions">Conclusions</a><br/>
</p><h2 id="heading-important-note-on-the-article-update">Important Note on the Article Update</h2>
<p>VSCode changed extension API several time, and I had to change the extension, because new VSCode versions broke backward compatibily. After v. 5.8.1, I used two different versions for software development and article wriring.</p><p>Finally, I’ve found time to fix it. Since v. 5.8.1, the complete functionality is back, but the latest version of Extensible Markdown may not work with some earlier VSCode versions. Presently, it requires VSCode v. 1.84.2. This extension is reintroduced to the <a href="https://marketplace.visualstudio.com/search?term=SAKryukov&target=VSCode">Visual Studio Marketplace</a>. Enjoy!</p><h2 id="heading-introduction">Introduction</h2>
<p><img src="Resources-articles/2017-06-29.All-in-One-Toolchain-for-Article-Writing-with-Visual-Studio-Code.logo.webp" alt="Logo" data-src="Resources-articles/2017-06-29.All-in-One-Toolchain-for-Article-Writing-with-Visual-Studio-Code.logo.webp" /></p><p>In my previous article on the topic, <a href="https://www.codeproject.com/Articles/1177895/Helpful-Toolchain-for-Article-Writing"><em>Helpful Toolchain for Article Writing</em></a>, I expressed <a href="https://www.codeproject.com/Articles/1177895/Helpful-Toolchain-for-Article-Writing#writing-is-annoying">the annoyance of article writing</a> and tried to explain the importance of better tooling. Some variants of the toolchain I created in response to the challenge greatly improved my writing performance and promoted some piece in mind, but were far from perfection. Even the use of Visual Studio 2015 as a writing tool presented some noticeable delays. Anyway, it worked out as a proof of the concept: this activity pays off with the first article written.</p><p>Recently, I tried out <a href="https://code.visualstudio.com">Visual Studio Code</a> for the first time and immediately paid attention to the support of <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>. Could it be used for article writing? My verdict was: “almost there”. All the available support and extension could not make a really usable toolchain, without considerable additional efforts, including some code development. Some critically important features were simply missing. After some research, I figured out that the comprehensive solution needs one more <a href="https://code.visualstudio.com/docs/extensions/overview">Visual Studio Code extension</a>, to generate HTML files suitable for immediate submission through the CodeProject article submission wizard, as well as many other purposes. Note that my idea of preparation of an article for CodeProject is the possibility to paste the article to the article submission wizard in one step, without any modifications.</p><p>After I created this extension and published it on Visual Studio Marketplace, I found results quite practical. My toolchain became very lightweight and convenient.</p><p>This article is fully written with the use of the all in one toolchain based on Visual Studio Code.</p><h2 id="heading-visual-studio-code">Visual Studio Code</h2>
<p>Why would I try out Visual Studio Code? I’m afraid to say, the benefits of this tool are somewhat understated. The way it is marketed creates the impression that this is a Visual Studio dramatically cut down in features for the sake of multi-platform qualities. This is not true. For example, it’s quite unfair to consider <a href="https://www.eclipse.org">Eclipse</a> as an “<a href="https://en.wikipedia.org/wiki/Eclipse_%28software%29">integrated development environment</a>” and Visual Studio Code as “<a href="https://en.wikipedia.org/wiki/Visual_Studio_Code">source code editor</a>”.</p><p>Perhaps the most impressive quality of Visual Studio Code is its speed, especially in contrast to <a href="https://www.visualstudio.com">“real” Visual Studio</a>. Another pleasing feature: it is really friendly to the developers used to Visual Studio.</p><p>Anyway, my initial interest started with attempts to find the best support of development and debugging of <a href="https://dotnet.github.io">.NET Core</a> code. But this is a whole different story…</p><h2 id="heading-available-extensions">Available Extensions</h2>
<p>There is a number of out-of-the-box Markdown-related Visual Studio Code <em>extensions</em> on the <a href="https://marketplace.visualstudio.com">Visual Studio Marketplace</a>. As I could see, at the moment of writing they all had considerable deficiencies or defects. If they were perfect, this article would be totally redundant.</p><h4 id="heading-vs-code-markdown2c-microsoft">VS Code Markdown, Microsoft</h4>
<p>Basic Markdown support extension is embedded in Visual Studio Code. It’s <em>id</em> is “Microsoft.vscode-markdown”. It provides basic document authoring and preview. The extension “<a href="https://marketplace.visualstudio.com/items?itemName=sakryukov.convert-markdown-to-html">Convert Markdown to HTML</a>” is based on this Microsoft extension and augments it with the most missing feature: saving converted Markdown in HTML files.</p><h4 id="heading-markdown-all-in-one">Markdown All in One</h4>
<p>This is the first extension I tried out. Despite its name the word “All” in its name seems to be a great exaggeration. Perhaps the only useful feature is its explicit Table of Contents (TOC) generation and update — see the <a href="https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one">description</a>. Nevertheless, I used this extension to generate TOC for <a href="https://www.codeproject.com/KB/mentor/1194125/Visual-Studio-Code-Markdown-samples.zip">Markdown samples</a>, just to avoid the dependency on the “<a href="https://www.npmjs.com/package/markdown-it">markdown-it</a>” <a href="https://www.npmjs.com/browse/keyword/markdown-it-plugin">plug-ins</a> I rely on <a href="#the-solution-extensible-markdown-converter">in my approach</a>.</p><p>The solution looks too heavy, because it does not depend on the Microsoft “VS Code Markdown” extension. Instead, the solution is based on separate installation of node.js <a href="https://www.npmjs.com">npm</a> and npm modules, such as <a href="https://www.npmjs.com/package/markdown-it">markdown-it</a> and <a href="https://www.npmjs.com/package/markdown-it-named-headers">markdown-it-named-headers</a>, and more. The modules are supplied with the extension, duplicating the modules installed with the Visual Code Installation, which may lead to mismatched behavior in future.</p><p>Unfortunately, a critical bug was found in <a href="https://www.npmjs.com/package/markdown-it-named-headers">markdown-it-named-headers</a>: identical heading names would break uniqueness of the values of <code>id</code> attributes, which generated renders HTML invalid. Besides, it makes little sense to have separate plug-ins for the generation of <code>id</code> attributes and Table of Constants. Instead, these two parts of functionality are closely related and should be supported in a unified plug-in, to act consistently.</p><h4 id="heading-code-spellchecker-extension">Code Spellchecker Extension</h4>
<p>This extension is described <a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker">here</a>. It provides reasonably convenient spell checking and quick type fix workflow.</p><p>Spelling problems are shown directly in the text, so they can be fixed through IntelliSense. In particular, a correct word can be added either to a global (per user) or local (per <em>workspace</em>) dictionary. The Markdown formatting does not break the detection of spelling problems. Quite importantly, there is a summary view of the problems, “Spell Checker Information”, which can be used to make sure no problems are overlooked, and to turn the feature on or off. Below, I’ll show how to add this and other commands to <a href="#keyboard-binding">keyboard binding</a>.</p><h2 id="heading-so2c-where-is-the-problem3f">So, Where is the Problem?</h2>
<p>The most important part is not done: generation of the HTML file. So far, we did not get acceptable out-of-the-box Visual Studio Code extensions. Some output the document as HTML, but do in not in the way we can easily use, for example, put the content in the system <em>clipboard</em>.</p><p>Some ideas are provided on this <a href="https://code.visualstudio.com/docs/languages/markdown">Visual Studio Code documentation page</a>. The main idea is: the conversion to HTML should work as project build, with familiar Ctrl+Shift+B shortcut, show the result in the output window, and so on. For this purpose, proper build task should be defined in “.vscode/tasks.json”.</p><p>Will it work? Actually, it won’t. There is a number of problems rendering the whole process virtually unusable. Some problems are minor and are easy to fix. But the worst problem is: <strong>the generated file lacks <code>id</code> attributes in headings</strong>. This raises the question: why would we automatically generate a TOC with the extension code, if it won’t work with the resulting HTML anyway? Notably, the extension preview navigates with TOC correctly. This is done via another <a href="https://nodejs.org">node.js</a> module, “<a href="https://www.npmjs.com/package/markdown-it-named-headers">markdown-it-named-headers</a>”, a plug-in for “markdown-it”. It cannot be used via the command-line “markdown-it” interface, as named headers are optional and not exposed through command-line arguments. Besides, they can be considered dangerous. Before explaining my solution, I need to give the reader a warning:</p><p><p><strong>Warning:</strong>
Unfortunately, in automatic <code>id</code> and TOC generation, there is nothing to guarantee uniqueness of <code>id</code> values, as it is done in some processors (such as <a href="http://pandoc.org">Pandoc</a>, for example). Possible <code>id</code> clash, strictly speaking, would render HTML invalid. At least, the anchor-based navigation on the CodeProject article page can be broken. That said, it can happen if one creates two or more identical headers or explicitly enter non-unique <code>id</code> attributes in HTML.</p></blockquote>
<p>Despite of this problem, uniqueness of the <code>id</code> values is not broken in the case if identical headings; this problem is solved in Extensible Markdown Converter, version 4.0.0.</p><p>Having said that, let’s consider really working solution, based on creation of separate Visual Studio Code extension.</p><h2 id="heading-the-solution3a-extensible-markdown">The Solution: Extensible Markdown</h2>
<p>The techniques of extension development are described in the <a href="https://code.visualstudio.com/docs/extensions/publish-extension">Visual Studio Code documentation</a>.</p><h3 id="heading-markdown-it-initialization">Markdown-it Initialization</h3>
<p id="src..main.js">Main idea of the solution is this: instead of packaging full set on npm modules for Markdown support, we need to reuse the resources provided by the dependency extension “<a href="#vs-code-markdown-microsoft">VS Code Markdown</a>”:</p><pre lang="JavaScript"><span class="comment text highlighter">// extension host makes it always accessible to extensions:</span>
<span class="keyword highlighter">var</span> vscode = require(<span class="literal string highlighter">'vscode'</span>);  

<span class="keyword highlighter">const</span> idToc = require(<span class="literal string highlighter">"./id.toc.js"</span>);

<span class="comment text highlighter">//...</span>

<span class="keyword highlighter">if</span> (!lazy.markdownIt)
    lazy.markdownIt = (<span class="keyword highlighter">function</span> () { <span class="comment text highlighter">// modify, depending in settings</span>
    <span class="keyword highlighter">const</span> extension = vscode.extensions.getExtension(<span class="literal string highlighter">"Microsoft.vscode-markdown"</span>);
    <span class="keyword highlighter">if</span> (!extension) <span class="keyword highlighter">return</span>;
    <span class="keyword highlighter">const</span> extensionPath = path.join(extension.extensionPath, <span class="literal string highlighter">"node_modules"</span>);
    <span class="keyword highlighter">let</span> md = require(path.join(extensionPath, <span class="literal string highlighter">"markdown-it"</span>))().set(optionSet);
    md.use(idToc, {
        enableHeadingId: lazy.settings.headingId, 
        idPrefix: lazy.settings.headingIdPrefix,
        stringModule: require(path.join(extensionPath, <span class="literal string highlighter">"string"</span>)),
        markerPattern: <span class="keyword highlighter">new</span> <span class="literal keyword highlighter">RegExp</span>(lazy.settings.tocRegex, <span class="literal string highlighter">"m"</span>),
        includeLevel: lazy.settings.tocIncludeLevels,
        tocContainerClass: lazy.settings.tocContainerClass,
        tocListType: lazy.settings.tocListType
    });
    <span class="keyword highlighter">for</span> (<span class="keyword highlighter">let</span> pluginData <span class="keyword highlighter">in</span> additionalPlugins) {
        <span class="keyword highlighter">let</span> plugin;
        <span class="keyword highlighter">try</span> {
            plugin = require(additionalPlugins[pluginData].name);
        } <span class="keyword highlighter">catch</span> (requireException) {
            <span class="keyword highlighter">continue</span>;
        } <span class="comment text highlighter">//exception</span>
        md = md.use(plugin, additionalPlugins[pluginData].options);
    } <span class="comment text highlighter">// using additionalPlugins</span>
    <span class="keyword highlighter">return</span> md;
})();

<span class="comment text highlighter">// now we can use markdownIt to render HTML</span>

<span class="comment text highlighter">//...</span>
</pre><p>Here, two <a href="https://nodejs.org">node.js</a> modules are loaded: “<a href="https://www.npmjs.com/package/markdown-it">markdown-it</a>” and “string”. They come with the embedded extension &quot;“Microsoft.vscode-markdown” and can be found by its <code>id</code>. The extension “string” is used by the module “idToc” embedded in the extension “Extensible Markdown Converter”. It implements generation of headings <code>id</code> attributes and Table of Contents and plays the role of the <a href="https://www.npmjs.com/package/markdown-it">markdown-it</a> plug-in.</p><p>Note that the function setting up <code>markdownIt</code> also loads <em>additional plug-ins</em>. The plug-ins can be installed in some arbitrary directory by the user and configured in “settings.json” shown <a href="#heading.customized-workspace-settings">explained below</a>.</p><h3 id="heading-performance-optimization-with-lazy-evaluation">Performance Optimization with Lazy Evaluation</h3>
<p id="src..lazy.js">Another interesting point is using <em>lazy evaluation</em>. The extension itself is loaded lazily, only on the events when it is really required. It would be tempting to perform relatively long operations, such as <a href="https://www.npmjs.com/package/markdown-it">markdown-it</a> setup and processing of the setting, during extension activation, and not during execution of each commands. It won’t work correctly though, because between commands the use can enter some changes rendering current state of <a href="https://www.npmjs.com/package/markdown-it">markdown-it</a> or settings data invalid. In particular, the user can edit settings or simply one or another CSS file. Lazy evaluation combined with some invalidation mechanism solves this problem. This is how:</p><pre lang="JavaScript"><span class="keyword highlighter">const</span> lazy = { markdownIt: undefined, settings: undefined };

<span class="comment text highlighter">// ...</span>

<span class="keyword highlighter">if</span> (!lazy.settings)
    lazy.settings = getSettings();

<span class="comment text highlighter">// ...</span>

<span class="keyword highlighter">if</span> (!lazy.markdownIt) <span class="comment text highlighter">// already shown in first code sample</span>
    lazy.markdownIt = (<span class="keyword highlighter">function</span> () {
        <span class="comment text highlighter">// ...</span>
    };    

<span class="comment text highlighter">// ...</span>

vscode.workspace.onDidChangeTextDocument(<span class="keyword highlighter">function</span> (e) {
    <span class="keyword highlighter">if</span> (e.document === vscode.window.activeTextEditor.document)
        provider.update(previewUri);
    <span class="keyword highlighter">if</span> (e.document.languageId == <span class="literal string highlighter">"css"</span>) <span class="comment text highlighter">// any change in CSS is detected</span>
        lazy.settings = undefined;
}); <span class="comment text highlighter">//vscode.workspace.onDidChangeTextDocument</span>
vscode.workspace.onDidChangeConfiguration(<span class="keyword highlighter">function</span> (e) {
    lazy.settings = undefined;
    lazy.markdownIt = undefined;
}); <span ="comment text highlighter">//vscode.workspace.onDidChangeConfiguration</span>
</pre><h3 id="heading-auto-numbering">Auto-Numbering</h3>
<p>Version 5.0.0 introduced optional user configured auto-numbering with rich set of features. It is implemented as a part of the embedded plug-in. This plug-in is also published on <a href="https://www.npmjs.com">npm</a> as a <a href="https://www.npmjs.com/package/markdown-it-id-and-toc">separate product</a>.</p><p>First of all, all options come on two levels: general for the entire document (named <code>default*</code>) and per heading level, described in the property <code>pattern</code>. The exclusion is the option <code>standAlong</code> which appears only in <code>patter</code> and is only defined for individual heading levels.</p><p>By default, a heading number is shown as a multi-component string including number of upper-level headings, such as in “2.11.3”. The option <code>standAlong</code> is used to disable upper-level part, showing, in this example, just “3”.</p><table data-line="189" class="code-line" dir="auto">
<thead data-line="189" class="code-line" dir="auto">
<tr data-line="189" class="code-line" dir="auto">
<th>Property Name</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody data-line="191" class="code-line" dir="auto">
<tr data-line="191" class="code-line" dir="auto">
<td>prefix<br/>defaultPrefix</td>
<td><code>&quot;&quot;</code></td>
<td>String which comes before number. Typical used include &quot;Chapter &quot;, &quot;Part &quot;</td>
</tr>
<tr data-line="192" class="code-line" dir="auto">
<td>suffix<br/>defaultSuffix</td>
<td><code>&quot;. &quot;</code></td>
<td>String which comes after number. It is used to separate number and heading caption</td>
</tr>
<tr data-line="193" class="code-line" dir="auto">
<td>start<br/>defaultStart</td>
<td>1</td>
<td>Starting number in each numbered section. It can be any integer number, any string parsable to an integer number or any character.</td>
</tr>
<tr data-line="194" class="code-line" dir="auto">
<td>separator<br/>defaultSeparator</td>
<td>1</td>
<td>Starting number in each numbered section. It can be any integer number, any string parsable to an integer number or any character.</td>
</tr>
<tr data-line="195" class="code-line" dir="auto">
<td>standAlong</td>
<td><code>undefined</code></td>
<td>“Stand along” flag defining that for some individual levels of headings, the components of number inherited from upper-level headings are not shown</td>
</tr>
</tbody>
</table>
<p>Example of auto-numbering options defined as a first paragraph in the document:</p><pre lang="Markdown">@numbering <span class="operator highlighter">{</span>
    <span class="property highlighter">"enable"</span>: true,
    <span class="property highlighter">"defaultSuffix"</span>: <span class="literal string highlighter">". "</span>,
    <span class="property highlighter">"pattern"</span>: <span class="operator highlighter">[</span>
        <span class="operator highlighter">{</span><span class="operator highlighter">}</span>,
        <span class="operator highlighter">{</span> <span class="property highlighter">"prefix"</span>: <span class="property highlighter">"Chapter ", "start"</span>: <span class="operator highlighter">[</span><span class="property highlighter">"One", "Two", "Three", "Four"], "suffix"</span>: <span class="literal string highlighter">": "</span> <span class="operator highlighter">}</span>,
        <span class="operator highlighter">{</span><span class="operator highlighter">}</span>,
        <span class="operator highlighter">{</span> <span class="property highlighter">"standAlong"</span>: true <span class="operator highlighter">}</span>,
        <span class="operator highlighter">{</span> <span class="property highlighter">"start"</span>: <span class="property highlighter">"a", "suffix"</span>: <span class="property highlighter">") ", "standAlong"</span>: true <span class="operator highlighter">}</span>
    <span class="operator highlighter">]</span>
<span class="operator highlighter">}</span>
</pre><p>Version 5.8.0 introduced new simplified format for the in-document specification of the auto-numbering options.</p><p>The format used previously is JSON; it still can be used, but it is not very suitable for human input and is not fault-tolerant. Presently, it takes precedence. If JSON parsing fails, new parser tried to parse the content of the <code>[](= ... =)</code> tag using new grammar:</p><ul data-line="216" class="code-line" dir="auto">
<li>Each property is placed on a separate line</li>
<li>Leading and trailing blank spaces and spaced between syntactic elements are ignored</li>
<li>Line syntax: <code>&lt;property&gt;: &lt;value&gt;</code></li>
<li>Document properties:
<ul data-line="220" class="code-line" dir="auto">
<li>enabled: true</li>
<li>defaultStart: <code>&lt;value&gt;</code></li>
<li>defaultSeparator: <code>&lt;value&gt;</code></li>
<li>defaultPrefix: <code>&lt;value&gt;</code></li>
<li>defaultSuffix: <code>&lt;value&gt;</code></li>
</ul>
</li>
<li>Heading level properties:
<ul data-line="226" class="code-line" dir="auto">
<li>h<code>&lt;level&gt;</code>.standAlong: true</li>
<li>h<code>&lt;level&gt;</code>.start: <code>&lt;value&gt;</code></li>
<li>h<code>&lt;level&gt;</code>.separator: <code>&lt;value&gt;</code></li>
<li>h<code>&lt;level&gt;</code>.prefix: <code>&lt;value&gt;</code></li>
<li>h<code>&lt;level&gt;</code>.suffix: <code>&lt;value&gt;</code>
here, <code>&lt;level&gt;</code> values 1, 2, … correspond to Markdown headings <code>#</code>, <code>##</code>, … or HTML elements <code>h1</code>, <code>h2</code>, …</li>
</ul>
</li>
<li>Valid values for .start, defaultStart:
<ul data-line="233" class="code-line" dir="auto">
<li>integer number</li>
<li>string (in this case, only first character is used)</li>
<li>array of strings</li>
</ul>
</li>
</ul>
<p>If a line fails to parse, it is ignored. It can be used for comments.</p><p>Example of auto-numbering option in-document specifications:</p><pre lang="Markdown"><span class="keyword highlighter">@numbering</span> {
    <span class="property highlighter">enable</span>: true
    <span class="property highlighter">defaultSuffix</span>: 1". "
    <span class="property highlighter">h2.prefix</span>: "Chapter "
    <span class="property highlighter">h2.start</span>: ["One", "Two", "Three", "Four"]
    <span class="property highlighter">h2.suffix</span>: ": "
    <span class="property highlighter">h5.standAlong</span>: true
    <span class="property highlighter">h4.standAlong</span>: true
    <span class="property highlighter">h5.start</span>: "a"
    <span class="property highlighter">h5.suffix</span>: ") "
}
</pre><p>Auto-numbering “start” option can be any integer number or a string representing such number, any character, or, since version 5.5.5, an array of strings representing heading numbers, such as <code>[&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</code>. These different categories are iterated in natural different ways. In particular, a character-based name is iterated by incrementing of its Unicode <em>code point</em>, such as in “A”, “B”, “C”…</p><p>In implementation, an interesting point here is the universal <code>Iterator</code> covering all these cases:</p><pre lang="JavaScript"><span class="keyword highlighter">function</span> <span class="name function highlighter">Iterator</span>(first) {
    <span class="keyword highlighter">if</span> (first.constructor == Array) <span class="keyword highlighter">this</span>.array = first;
    <span class="keyword highlighter">this</span>.counter = <span class="keyword highlighter">this</span>.array ? <span class="literal numeric highlighter">0</span> : first;
    Iterator.prototype.toString = <span class="keyword highlighter">function</span> () {
        <span class="keyword highlighter">return</span> <span class="keyword highlighter">this</span>.array ?
            <span class="keyword highlighter">this</span>.array[<span class="keyword highlighter">this</span>.counter].toString() : <span class="keyword highlighter">this</span>.counter.toString()
    }; <span class="comment text highlighter">// toString</span>
    Iterator.prototype.next = <span class="keyword highlighter">function</span> () {
        <span class="keyword highlighter">if</span> (<span class="keyword highlighter">this</span>.array)
            <span class="keyword highlighter">if</span> (!<span class="keyword highlighter">this</span>.array[<span class="keyword highlighter">this</span>.counter + <span class="literal numeric highlighter">1</span>]) {
                <span class="keyword highlighter">this</span>.counter = <span class="keyword highlighter">this</span>.array[<span class="keyword highlighter">this</span>.array.length - <span class="literal numeric highlighter">1</span>];
                <span class="keyword highlighter">delete</span> <span class="keyword highlighter">this</span>.array;
            } <span class="keyword highlighter">else</span>
                <span class="keyword highlighter">this</span>.counter++;
        <span class="keyword highlighter">if</span> (!<span class="keyword highlighter">this</span>.array) { <span class="comment text highlighter">// again, because it could have changed by delete this.array </span>
            <span class="keyword highlighter">let</span> tryNumeric = parseInt(<span class="keyword highlighter">this</span>.counter);
            <span class="keyword highlighter">if</span> (isNaN(tryNumeric)) {
                <span class="keyword highlighter">let</span> codePoint = <span class="keyword highlighter">this</span>.counter.codePointAt();
                <span class="keyword highlighter">this</span>.counter = String.fromCodePoint(++codePoint);
            } <span class="keyword highlighter">else</span>
                <span class="keyword highlighter">this</span>.counter = (++tryNumeric).toString();
        } <span class="comment text highlighter">//if</span>
        <span class="keyword highlighter">return</span> <span class="keyword highlighter">this</span>;
    } <span class="comment text highlighter">//next</span>
} <span class="comment text highlighter">//Iterator</span>
</pre><p>Let’s see how it works.</p><p>Let’s say, we have the following Markdown fragment, included in other Markdown files, different in auto-numbering options:</p><pre lang="Markdown"><span class="keyword highlighter">##</span> Contents

<span class="keyword highlighter">@toc</span>

<span class="keyword highlighter">##</span> Introduction

<span class="keyword highlighter">##</span> Something Else 

<span class="keyword highlighter">###</span> Section

<span class="keyword highlighter">###</span> Another Section

<span class="keyword highlighter">####</span> Sub-Section
</pre><p>To enable default auto-numbering include it in this way:</p><pre lang="Markdown"><span class="keyword highlighter">@numbering</span> {
    <span class="property highlighter">enable</span>: true
}

<span class="keyword highlighter">@include</span>(body.md)
</pre><p>It will give as the following TOC:</p><div  data-line="316" class="code-line" dir="auto" ></div>
<div class="toc"><ul style="list-style-type: none;"><li>1. <a href="#heading.contents">Contents</a></li><li>2. <a href="#heading.introduction">Introduction</a></li><li>3. <a href="#heading.something-else">Something Else</a><ul style="list-style-type: none;"><li>1. <a href="#heading.section">Section</a></li><li>2. <a href="#heading.another-section">Another Section</a><ul style="list-style-type: none;"><li>3.2.1. <a href="#heading.sub-section">Sub-Section</a></li></ul></li></ul></li></ul></div>
<p>Now, let’s use some advanced auto-numbering options:</p><pre lang="Markdown"><span class="keyword highlighter">@numbering</span> {
    <span class="property highlighter">enable</span>: true
    <span class="property highlighter">defaultSuffix</span>: " "
    <span class="property highlighter">h2.prefix</span>: "Chapter "
    <span class="property highlighter">h2.suffix</span>: ": "
    <span class="property highlighter">h2.start</span>: ["One", "Two", "Three"]
    <span class="property highlighter">h4.start</span>: "a"
    <span class="property highlighter">h4.suffix</span>": ") "
    <span class="property highlighter">h4.standAlong</span>: true
}

<span class="keyword highlighter">@include</span>(body.md)

<span class="keyword highlighter">##</span> Out of Chapter Names

No more names in "start": ["One", "Two", "Three", "Four"]

<span class="keyword highlighter">##</span> Using Letters Instead of Names
</pre><p>It will give us more fancy TOC:</p><div  data-line="342" class="code-line" dir="auto" ></div>
<div class="toc"><ul style="list-style-type: none;"><li>Chapter One: <a href="#heading.contents">Contents</a></li><li>Chapter Two: <a href="#heading.introduction">Introduction</a></li><li>Chapter Three: <a href="#heading.something-else">Something Else</a><ul style="list-style-type: none;"><li>1 <a href="#heading.section">Section</a></li><li>2 <a href="#heading.another-section">Another Section</a><ul style="list-style-type: none;"><li>a) <a href="#heading.sub-section">Sub-Section</a></li></ul></li></ul></li><li>Chapter U: <a href="#heading.out-of20chapter20names">Out of Chapter Names</a></li><li>Chapter V: <a href="#heading.using-letters20instead20of20names">Using Letters Instead of Names</a></li></ul></div>
<p>Note that iteration by <code>[&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;]</code> array went out of elements. Then next iteration is performed in the following way: the last element is parsed as a character and incremented by its code point. It gives us “U” and “V”. This feature is designed to handle such situation gracefully, so the author could easily detect where more array elements needs to be supplied, without breaking if the TOC structure.</p><p>Also note heading number 1, 2 and “a)”. This is where the “standAlong” option is used, and the specialized <code>&quot;suffix&quot;: &quot;) &quot;</code> for “a”.</p><h3 id="heading-setting-up-additional-plug-ins">Setting up Additional Plug-ins</h3>
<p id="src..additional.plugins.js">The object <code>additionalPlugins</code> is constructed from the settings data in conservative manner: if something goes wrong, plug-in data is not added:</p><pre lang="JavaScript"><span class="keyword highlighter">const</span> additionalPlugins = (<span class="keyword highlighter">function</span> () {
    <span class="keyword highlighter">let</span> result = [];
    <span class="keyword highlighter">if</span> (!settings.additionalPlugins) <span class="keyword highlighter">return</span> result;
    <span class="keyword highlighter">if</span> (!settings.additionalPlugins.plugins) <span class="keyword highlighter">return</span> result;
    <span class="keyword highlighter">if</span> (!settings.additionalPlugins.plugins.length) <span class="keyword highlighter">return</span> result;
    <span class="keyword highlighter">if</span> (settings.additionalPlugins.plugins.length &lt; <span class="literal numeric highlighter">1</span>) <span class="keyword highlighter">return</span> result;
    <span class="keyword highlighter">let</span> effectiveParentPath = settings.additionalPlugins.absolutePath;
    <span class="keyword highlighter">if</span> (!effectiveParentPath) {
        <span class="keyword highlighter">let</span> relativePath = settings.additionalPlugins.relativePath;
        <span class="keyword highlighter">if</span> (!relativePath) <span class="keyword highlighter">return</span> result;
        relativePath = relativePath.toString();
        effectiveParentPath =
            path.join(vscode.workspace.rootPath, relativePath);
    } <span class="comment text highlighter">//if </span>
    <span class="keyword highlighter">if</span> (!effectiveParentPath) <span class="keyword highlighter">return</span> result;
    <span class="keyword highlighter">if</span> (!fs.existsSync(effectiveParentPath.toString())) <span class="keyword highlighter">return</span> result;
    <span class="keyword highlighter">for</span> (<span class="keyword highlighter">let</span> pluginDataProperty <span class="keyword highlighter">in</span> settings.additionalPlugins.plugins) {
        <span class="keyword highlighter">const</span> pluginData =
            settings.additionalPlugins.plugins[pluginDataProperty];
        <span class="keyword highlighter">if</span> (!pluginData.name) <span class="keyword highlighter">continue</span>;
        <span class="keyword highlighter">const</span> effectivePath =
            path.join(
                effectiveParentPath.toString(),
                pluginData.name.toString());
        <span class="keyword highlighter">if</span> (!fs.existsSync(effectivePath)) <span class="keyword highlighter">continue</span>;
        <span class="keyword highlighter">if</span> (!pluginData.enable) <span class="keyword highlighter">continue</span>;
        result.push({name: effectivePath, options: pluginData.options});
    } <span class="comment text highlighter">// loop settings.additionalPlugins.plugins</span>
    <span class="keyword highlighter">return</span> result;
}()); <span class="comment text highlighter">//additionalPlugins</span>
</pre><p>Naturally, “package.json” should claim the extension “VS Code Markdown” in its dependencies:</p><pre lang="JSON"><span class="operator highlighter">{</span>
    <span class="property highlighter">"name"</span>: <span class="literal string highlighter">"convert-markdown-to-html"</span>,
    <span class="property highlighter">"displayName"</span>: <span class="literal string highlighter">"Convert Markdown to HTML"</span>,
    <span class="property highlighter">"description"</span>: <span class="literal string highlighter">"Converts Markdown files and saves them as HTML"</span>,

    // ...
    
    <span class="property highlighter">"dependencies"</span>: <span class="operator highlighter">{</span>
        <span class="property highlighter">"vscode"</span>: <span class="literal string highlighter">"^1.13.1"</span>
    <span class="operator highlighter">}</span>,
    <span class="property highlighter">"extensionDependencies"</span>: <span class="operator highlighter">[</span>
        <span class="literal string highlighter">"Microsoft.vscode-markdown"</span>
    <span class="operator highlighter">]</span>,
    
    // ...

<span class="operator highlighter">}</span>
</pre><p>The function <a href="#src..main.js"><code>getMarkdownPlugin</code></a> solves some more problems unsolved by existing extensions. First, it enables generation of <code>id</code> attributes in headings, which are used in TOC and elsewhere. Another important improvement is the use of the <a href="https://www.npmjs.com/package/markdown-it">markdown-it</a> <em>typographer</em>.</p><p>One noticeable annoyance of the extension preview was that the <em>typographer</em> feature of the node.js module “markdown-it” is not used. I wrote about similar feature <a href="https://www.codeproject.com/Articles/1177895/Helpful-Toolchain-for-Article-Writing">in my previous article</a> on the topic; check out the description of the “–smart” command-line option. In terms of the “markdown-it” module, this is the <em>typographer</em> option, which should be set before rendering. This is done in the conversion script “build.js”, so the input markup such as em dash (“‐‐‐”), apostrophes or unpaired quotation marks will be shown in a typographically correct way as “—”, “”, “'”, etc.    This way, the extension preview and the final output will look different. Another reason for the difference is “fancy formatting” of the preview, not entirely controlled by CSS.</p><p>The typographer behavior is explained in detail in the <a href="https://sakryukov.github.io/vscode-markdown-to-html/#typographer">“Extensible Markdown Converter” documentation</a>.</p><p>The problem of mismatch between preview and generated HTML file was solved in version 2.2.0. Now preview precisely matches the file, because it’s generated from the same source. For further detail, please see <a href="https://sakryukov.github.io/vscode-markdown-to-html/#preview">documentation on preview</a>.</p><p>Another feature to implement is adding the HTML header and footer to the generated body. The module <a href="https://www.npmjs.com/package/markdown-it">markdown-it</a> itself does not do it. There is one particular reason why it is important enough: UTF-8 encoding needs to be specified in the <code>head</code> element, to make rendering correct. CodeProject does it anyway, but it’s important to check up the document before pasting it to the CodeProject article submission wizard.</p><p>For other implementation detail, please see <a href="https://github.com/SAKryukov/vscode-markdown-to-html">original source code</a>.</p><h2 id="heading-customized-workspace-settings">Customized Workspace Settings</h2>
<p id="src..settings.json">All settings can be customized either globally (per user), or per <em>workspace</em>. We can use it to customize markdown preview and behavior (first of all, IntelliSense) to become suitable for the workspace used for article authoring. To do it per workspace, we need to create a file “.vscode/settings.json”:</p><pre lang="JSON"><span class="operator highlighter">{</span>
    <span class="property highlighter">"markdown.extension.convertToHtml.reportSuccess"</span>: true, // default
    <span class="property highlighter">"markdown.extension.convertToHtml.showHtmlInBrowser"</span>: false, // default
    <span class="property highlighter">"markdown.extension.convertToHtml.embedCss"</span>: false, // default
    <span class="property highlighter">"markdown.extension.convertToHtml.outputPath"</span>: <span class="literal string highlighter">""</span>, // default
    <span class="property highlighter">"markdown.extension.convertToHtml.titleLocatorRegex"</span>:
        <span class="literal string highlighter">"^(.*?)\\[\\]\\(title\\)"</span>, // default
    // markdown-it options, all defaults:
    <span class="property highlighter">"markdown.extension.convertToHtml.options.allowHTML"</span>: true,
    // <span class="literal string highlighter">"markdown-it-named-headers"</span> plug-in,
    // adds id attributes to h1 .. h6 elements:
    <span class="property highlighter">"markdown.extension.convertToHtml.options.headingId"</span>: true,
    // converts <span class="literal string highlighter">"link-like"</span> text: for ex., <span class="literal string highlighter">"http://my.com"</span>
    // to HTML anchors:
    <span class="property highlighter">"markdown.extension.convertToHtml.options.linkify"</span>: false,
    // replaces new line marker with br HTML element:
    <span class="property highlighter">"markdown.extension.convertToHtml.options.br"</span>: true,
    // typographer, see the documentation:
    // https://sakryukov.github.io/vscode-markdown-to-html/#typographer
    // :
    <span class="property highlighter">"markdown.extension.convertToHtml.options.typographer"</span>: true,
    // applicable if typographer is true:
    // 4 characters, replacement for <span class="literal string highlighter">""</span> and '':
    <span class="property highlighter">"markdown.extension.convertToHtml.options.smartQuotes"</span>: <span class="literal string highlighter">"“”‘’"</span>,    
    <span class="property highlighter">"markdown.extension.convertToHtml.options.additionalPlugins"</span>: <span class="operator highlighter">{</span>
        <span class="property highlighter">"absolutePath"</span>: null, // just a placeholder
        // relative to workspace:
        <span class="property highlighter">"relativePath"</span>: <span class="literal string highlighter">"../additional_plugins/node_modules"</span>, 
        <span class="property highlighter">"plugins"</span>: <span class="operator highlighter">[</span>
            <span class="operator highlighter">{</span>
                <span class="property highlighter">"name"</span>: <span class="literal string highlighter">"markdown-it-sub"</span>,
                <span class="property highlighter">"enable"</span>: true
            <span class="operator highlighter">}</span>,
            <span class="operator highlighter">{</span>
                <span class="property highlighter">"name"</span>: <span class="literal string highlighter">"markdown-it-sup"</span>,
                <span class="property highlighter">"enable"</span>: true
            <span class="operator highlighter">}</span>,
            <span class="operator highlighter">{</span>
                <span class="property highlighter">"name"</span>: <span class="literal string highlighter">"markdown-it-table-of-contents"</span>,
                <span class="property highlighter">"options"</span>: <span class="operator highlighter">{</span>
                    <span class="property highlighter">"includeLevel"</span>: <span class="operator highlighter">[</span>2, 3<span class="operator highlighter">]</span>,
                    <span class="property highlighter">"containerClass"</span>: <span class="literal string highlighter">"toc"</span>,
                    <span class="property highlighter">"listType"</span>: <span class="literal string highlighter">"ul"</span>
                <span class="operator highlighter">}</span>,
                <span class="property highlighter">"enable"</span>: true
            <span class="operator highlighter">}</span>,
            <span class="operator highlighter">{</span>
                <span class="property highlighter">"name"</span>: <span class="literal string highlighter">"markdown-it-footnote"</span>,
                <span class="property highlighter">"enable"</span>: true
            <span class="operator highlighter">}</span>
        <span class="operator highlighter">]</span>
    <span class="operator highlighter">}</span>,
    <span class="property highlighter">"markdown.styles"</span>: <span class="operator highlighter">[</span>
        // same styles used for preview are used in converted HTML files:
        <span class="literal string highlighter">"style.css"</span>, 
        <span class="literal string highlighter">"someMoreStyles.css"</span>
    <span class="operator highlighter">]</span>,
 
    // ...

    // Very important: remove entered words from suggestions,
    // leave only markdown syntax:
    <span class="property highlighter">"editor.wordBasedSuggestions"</span>: false,
    <span class="property highlighter">"[markdown]"</span>: <span class="operator highlighter">{</span> // for Markdown language id only:
        <span class="property highlighter">"editor.codeLens"</span>: true,
        <span class="property highlighter">"editor.lineNumbers"</span>: <span class="literal string highlighter">"off"</span>,
        <span class="property highlighter">"editor.rulers"</span>: <span class="operator highlighter">[</span>
            79 //CodeProject requirements for source code samples
        <span class="operator highlighter">]</span>
    <span class="operator highlighter">}</span>,
    <span class="property highlighter">"git.enabled"</span>: false, // git is used, but not with VS Code integration 
    <span class="property highlighter">"cSpell.enabled"</span>: true // default
<span class="operator highlighter">}</span>
</pre><p>All the options above “<code>markdown.styles</code>” are introduced by the extension “<a href="https://marketplace.visualstudio.com/items?itemName=sakryukov.convert-markdown-to-html">Extensible Markdown Converter</a>”. The option “<code>markdown.styles</code>” is shared by this extension and its dependency extension “<a href="#vs-code-markdown-microsoft">VS Code Markdown</a>”. If one of more CSS files is defined, they are used in the generated HTML files as <em>external</em> or <em>embedded</em> style sheets, depending on the option “<code>markdown.extension.convertToHtml.embedCss</code>”. The user is responsible for supplying the CSS files themselves.</p><p>Perhaps the most interesting “<a href="https://marketplace.visualstudio.com/items?itemName=sakryukov.convert-markdown-to-html">Convert Markdown to HTML</a>” option is “markdown.extension.convertToHtml.options.additionalPlugins”. Their behavior is explained in the <a href="https://github.com/SAKryukov/vscode-markdown-to-html/wiki/VSCode:-Extensible-Markdown-Converter">extension documentation</a>.</p><p>Note one specific plug-in package, “<a href="https://www.npmjs.com/package/markdown-it-table-of-contents">markdown-it-table-of-contents</a>”. It has its own options. They are transparently passed from “settings.json” to the extension code. The code fragment <a href="#src..main.js">shown above</a> explains how it is implemented.</p><p>The process of modification of settings is explained <a href="https://code.visualstudio.com/docs/getstarted/settings">here</a>. It makes certain sense to open the original file in Visual Studio Code and edit in text format, to keep full control and take the benefits of IntelliSense.</p><p>Some settings are copied to the local file “.vscode/settings.json” and not modified but added for convenience of experimenting; most of them are omitted from this code sample. Note two critical items: “editor.wordBasedSuggestions” and “editor.rulers”. First one is a work-around against showing all previously entered words as IntelliSense suggestions. The second one draws a vertical line at column 79, which is important for code samples: CodeProject requires all code sample lines to be within the 80-column range.</p><h2 id="heading-putting-all-together3a-cookbook-recipe">Putting All Together: Cookbook Recipe</h2>
<ol data-line="511" class="code-line" dir="auto">
<li>Install <a href="https://code.visualstudio.com">Visual Studio Code</a>; it will also install the built-in extension “VS Code Markdown” by Microsoft;</li>
<li>Install Visual Studio Code extension “<a href="https://marketplace.visualstudio.com/items?itemName=sakryukov.convert-markdown-to-html">Convert Markdown to HTML</a>”, described in the present article;</li>
<li>Install Visual Studio Code extension “<a href="https://marketplace.visualstudio.com/items?itemName=streetsidesoftware.code-spell-checker">Code Spellchecker</a>”;</li>
<li>Open some folder with Markdown documents with Visual Studio Code; in the code sample supplied with this article, this is the root directory, where “.vscode” is found.</li>
</ol>
<p>Optionally, I would also recommend installing Visual Studio Code extension “<a href="https://marketplace.visualstudio.com/items?itemName=alefragnani.numbered-bookmarks">Numbered Bookmarks</a>”; they are very useful for editing.</p><p>Everything is ready. Now you can test it. Create and open some .md file. In the editor, you will get the following commands:</p><ol data-line="520" class="code-line" dir="auto">
<li>“Ctrl-space”: see a <a href="#img.title">list of suggestions</a> in Markdown syntax and chose a snippet to enter;</li>
<li>“Ctrl+.”: if “Code Spellchecker” extension is activated, a problematic word is underlined and a cursor is located within this word, get a list of quick-fix suggestion and chose a corrected word;</li>
<li>“Ctrl+Shift+V”: Open Preview;</li>
<li>“Ctrl+K V”: Open Preview on side;</li>
<li>“Ctrl+/”: comment out or un-comment current line or selection;</li>
<li>Editor context menu: “Markdown: Convert to HTML”, converts the file loaded in a currently activated editor.</li>
<li>Editor context menu, Explorer context menu: “Markdown: Convert to HTML all .md files in workspace”.</li>
</ol>
<p>For full list of Markdown-related commands, press either F1 or Ctrl+Shift+P and enter “Markdown”; look for other commands as required.</p><h2 id="heading-versions">Versions</h2>
<h4>Initial version</h4>
<p>June 29, 2017</p><h4>Version 1.0.3</h4>
<p>July 4, 2017</p><p>Code is rewritten from scratch and published on Visual Studio Marketplace as a Visual Studio Code Extension <a href="https://marketplace.visualstudio.com/items?itemName=sakryukov.convert-markdown-to-html">“convert-markdown-to-html”</a>.</p><p>Article is almost completely rewritten.</p><h4>Version 1.1.0</h4>
<p>July 5, 2017</p><p>Added support for multiple CSS files and the option to embed CSS code in HTML.</p><h4>Version 1.1.1</h4>
<p>July 5, 2017</p><p>Fixed a bug in a relative path to CSS files.</p><h4>Version 2.1.0</h4>
<p>July 8, 2017</p><p>The Visual Studio Code extension title modified to “Extensible Markdown Converter”.</p><p>Since v. 2.0.0, the user can extend Markdown features by installing any of the <a href="https://www.npmjs.com/package/markdown-it">“markdown-it” plug-ins</a> that are <a href="https://www.npmjs.com/browse/keyword/markdown-it-plugin">abundantly available</a> in the <a href="https://www.npmjs.com">npm package registry</a>. All the packages can be configured from a single source: “settings.json”, <a href="https://code.visualstudio.com/docs/getstarted/settings">on the user or workspace level</a>.</p><p>That said, there is no a need for different Markdown extensions. It’s quite enough to have only the built-in extension combined with Extensible Markdown Converter. All required functionality can be assembled from available plug-ins using the single unified configuration design.</p><p>After this version was published, due to these radical improvements, the article was massively updated.</p><h4>Version 2.2.0</h4>
<p>July 9, 2017</p><ul data-line="572" class="code-line" dir="auto">
<li>Implemented preview identical to generated HTML</li>
<li>Improved performance (lazy evaluation of markdown-it module setup and settings)</li>
<li>In settings, implemented “outputPath” option</li>
</ul>
<p>Markdown code samples updated. Now they illustrate <a href="https://sakryukov.github.io/vscode-markdown-to-html/#additional-plug-ins">additional plug-ins</a> and newly developed techniques, such as <a href="https://sakryukov.github.io/vscode-markdown-to-html/#detecting-document-title">title detection</a>.</p><h4>Version 3.0.0</h4>
<p>July 13, 2017</p><ul data-line="582" class="code-line" dir="auto">
<li>Implemented extensible Markdown syntax coloring for each plug-in syntax, user-configurable</li>
<li>Implemented user-configurable syntax coloring for document title in input Markdown</li>
<li>Implemented file includes, with user-configurable syntax coloring</li>
<li>Added keybinding, to overwrite “VS Code Markdown” preview key bindings</li>
</ul>
<p>The change relative to version 2.3.0: location of the included file is now relative to the Markdown document location.</p><h4>Version 4.3.0</h4>
<p>Accumulated changes since Version 3.0.0:</p><ul data-line="593" class="code-line" dir="auto">
<li>Found critical bug in the external “markdown-it-named-headers” and “markdown-it-table-of-contents”: generated id values of headers were not unique. As a work-around, these external modules are eliminated and replaced with modules embedded in the extension.</li>
</ul>
<p>Major version is incremented because the default Markdown pattern for Table of Content has changed to <code>^\[\]\(toc\)</code>, which means “<code>[](toc)</code>” at the beginning of line. Potentially, it could break backward compatibility with existing Markdown documents using “<code>[[toc]]</code>”, but it’s easy to fix.</p><ul data-line="597" class="code-line" dir="auto">
<li>Added settings option: “markdown.extension.convertToHtml.tocIncludeLevels”, default [1, 2, 3, 4, 5, 6]</li>
<li>Added settings option: “markdown.extension.convertToHtml.tocContainerClass”, default “toc”</li>
<li>Added settings option: “markdown.extension.convertToHtml.tocListType”, default “ul”</li>
<li>Table of Contents and generation of heading <code>id</code> attributes unified in a single embedded module.</li>
<li>Added settings option: “markdown.extension.convertToHtml.options.headingIdPrefix”, default “heading.”</li>
<li>Fixed a bug in heading <code>id</code> attribute generation; now the set of used <code>id</code> values is reset on each rendering</li>
<li>Added logo</li>
</ul>
<h4>Version 5.2.0</h4>
<p>Extended syntax changed. Please see the <a href="https://sakryukov.github.io/vscode-extensible-markdown/index.html">current syntax here</a>.</p><p>Restored compatibility with later VSCode versions based on v.&amp;thinkp;1.84.2</p><h4>Version 5.3.0</h4>
<p>Updated documentation</p><h4>Version 5.8.0</h4>
<p>Fixed additional plugins feature, entire functionality re-tested</p><h4>Version 8.3.1</h4>
<p>Accumulated changes since Version 4.3.0:</p><ul data-line="623" class="code-line" dir="auto">
<li>Added advanced Markdown extension features based on embedded markdown-it plug-in:
<ul data-line="624" class="code-line" dir="auto">
<li>Syntax extension: a tag to mark a heading to be excluded from TOC</li>
<li>Extended options to make a choice between <code>ul</code> or <code>ol</code> elements in TOC, either globally or per TOC level</li>
<li>Extended options to add sets of HTML attributes to TOC list elements, either globally or per TOC level</li>
<li>Optional user-configurable <a href="#heading.auto-numbering">auto-numbering</a> with rich set of features</li>
</ul>
</li>
<li>Added images to conversion and preview commands and menu items to the editor title</li>
<li>Improved images</li>
<li>Found critical bugs in the legacy code of the embedded markdown-it plug-in, so this module is fully re-written</li>
<li>Improved handling of the case of invalid JSON in the in-doc auto-numbering specifications</li>
<li>Introduced new simplified format for in-document specifications of the auto-numbering op22tions</li>
<li>Improved id generation.</li>
</ul>
<p>The new current set features of features provides comprehensive handling of headings and TOC. Two related user-configurable syntax extensions are used “TOC” (by default, <code>[](toc</code> at the beginning of a paragraph) and “Exclude from TOC” (<code>by default, </code>[](notoc<code>anywhere in the heading). The</code>id<code>values and their references from TOC's</code><a href...>` anchors are created from a single source and guarantee referential integrity and uniqueness. The markers themselves are removed from output, unless the feature is disabled.</p><h4>Version 8.3.2</h4>
<p>The publication moved to GitHub (CodeProject is out of business, publications are accessible but not updateable).</p><h2 id="heading-conclusions">Conclusions</h2>
<p>After few prototypes of the solution and creation of the fully-fledged extension, I feel the result is pleasing. Since the first version, I already wrote many CodeProject articles, including the present article, and other documents. For the CodeProject publications during last years, I never touched the article text manually on the CodeProject article submission page. Instead, I only used copy and paste of the HTML, produced by this extension.</p><p>Since the first version of Extensible Markdown, Visual Studio Code seriously matured and now looks stabe, healthy and maintainable. It makes a great development tool, which can be used for article writing, with pleasure and piece in mind.</p><p>Happy writing!</p><div  data-line="649" class="code-line" dir="auto" ></div>
<!-- copy to CodeProject to here --------------------------------------------->
<p><a href="https://www.codeproject.com/Articles/1194125/All-in-One-Toolchain-for-Article-Writing-with-Visu">Original CodeProject source (obsolete)<a></p><p class="date">June 29, 2017 – January 3, 2025</p><div  data-line="655" class="code-line" dir="auto" ></div>
<script src="https://SAKryukov.github.io/publications/code/source-code-decorator.js"></script>


</body>
</html>
